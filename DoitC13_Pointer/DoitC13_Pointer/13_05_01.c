// int형 변수에 저장된 값을 1바이트 단위로 출력하기
#include <stdio.h>
main()
{
	// 4바이트 데이터 0x12345678 선언 및 초기화. 반복문에 쓸 i 선언
	int data = 0x12345678;
	// &data는 'int *' 형이다.
	// 그런데 이 주소를 저장할 포인터가 'char *' 이기 때문에
	// 자료형이 맞지 않아 형 변환을 해 준다.
	char *p = (char *)&data;
	for (int i = 0; i < 4; i++)
	{
		// p는 char*형이라서 시작 주소부터 1바이트 크기만 사용함
		printf("%X, ", *p);
		// p가 char*형이라서 1바이트 뒤에 있는 주소로 값이 변경됨.
		p++;
	}
}
/*
포인터 변수에 저장된 주소도 정수 값이기 때문에 일반 변수처럼 연산할 수 있다.
그런데 주소를 1만큼 증가시킨다는 의미가, 일반 수학 연산과는 다르다 -> 주의!
ex) 포인터 변수 short *p에 저장된 변수 값이 100일 때, 일반 수학 연산이라면 100+1=101
그런데 포인터 연산에서 저장된 주소가 100번지일 대에, +1 시키면 변수에 저장된 주소값은 102가 된다.
왜냐 하면 포인터에서 +1의 의미는 단순히 주소값에 1을 더한다는 의미가 아니라
그 다음 데이터의 주소를 의미하기 때문이다.
포인터 변수 p가 가리키는 대상의 크기가 2바이트인데,
이 포인터로 다음 데이터를 가리키려면
주소 값이 1이 아닌 2가 증가되어야 정상적으로 그 다음 데이터를 가리킬 수 있다.
/*
이 예제에서 data 변수는 int 형으로 선언되어 4바이트 크기인데,
data 변수를 가리킬 포인터 p 변수는 char * 형으로 선언했다. 
따라서 *p를 사용하면 data 변수의 시작 주소에서 1byte 크기만 사용할 수 있다.
그렇다고 해서 data의 시작 1바이트만 사용할 수 있는 것이 아니라
포인터의 주소 연산을 활용하면 data 변수의 나머지 부분도 1바이트씩 사용할 수 있다.
*/

/*
char *p1 = (char *)100; // p1에 100번지를 저장함
short *p2 = (short *)100; // p2에 100번지를 저장함
int *p3 = (int *)100; // p3에 100번지를 저장함
double *p4 = (double *)100; // p4에 100번지를 저장함

p1++; // 가리키는 대상의 크기가 char형(1byte)이기 때문에 p1에 저장된 주소 값이 101이 된다.
p2++; // 가리키는 대상의 크기가 short형(2byte)이기 때문에 p2에 저장된 주소 값이 102이 된다.
p3++; // 가리키는 대상의 크기가 int형(3byte)이기 때문에 p3에 저장된 주소 값이 103이 된다.
p4++; // 가리키는 대상의 크기가 double형(4byte)이기 때문에 p4에 저장된 주소 값이 104이 된다.

int *p라고 포인터 변수를 선언할 때, int 자료형은 포인터 변수의 크기를 의미하는 것이 아니라
포인터 변수가 가리키는 대상의 크기를 의미하는 것이다.

따라서 포인터 변수 p에 일반 변수 data의 주소 값을 저장하고, 포인터 변수 p를 이용하여 data 변수의 값을 변경하는 경우
두 변수의 자료형을 같게 지정하는 것이 일반적이다.
하지만 프로그래머가 의도적으로 이 두 크기를 다르게 사용하는 경우도 있다.

0x12345678 -> 0x78, 0x56, 0x34, 0x12
*/