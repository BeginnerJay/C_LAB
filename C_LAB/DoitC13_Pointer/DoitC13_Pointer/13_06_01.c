/*
void *p와 같이 변수를 선언하면, 포인터 변수 p에 주소 값을 저장할 수는 있지만,
해당 주소에서 값을 읽거나 저장할 때 사용하는 크기는 정해져 있지 않다.
즉 사용할 메모리의 시작 주소만 알고 끝 주소를 모를 때 사용하는 포인터 형식이다.
ex)
int data = 0;
void *p = &data; // data의 시작 주소를 저장함
*p = 5; // 오류 발생 : 대상 메모리의 크기가 지정되지 않음

포인터 변수 p를 사용하여 data 변수에 값 5를 대입하고 싶은 경우에는, 형 변환 문법을 사용하여
사용할 크기를 표기해 주면 일반 포인터처럼 사용할 수 있다.

int data = 0;
void *p = &data; // data의 시작 주소를 저장함
*(int *)p = 5; // 형 변환 문법을 사용하여, 대상의 크기를 4바이트로 지정하므로 data 변수에 5가 저장된다.

 void *는 포인터의 기능을 사용할 수 없게 되는 것이 아니다.
 자신이 사용할 대상의 크기 지정을 잠시 미룰 수 있는 것이다.
 */

 // void *를 이용하여 대상 메모리의 크기 조절하기

#include <stdio.h>
int Getdata(void *p_data, char type)
{
	int result = 0;
	// type 변수에 저장된 값을 기준으로 형 변환을 다르게 함
	if (type == 1)
	{
		result = *(char *)p_data; // 0x78(1byte)가 저장됨
	}
	else if (type == 2)
	{
		result = *(short *)p_data; // 0x5678(2byte)가 저장됨
	}
	else if(type == 4)
	{
		result = *(int *)p_data; // 0x12345678(4byte)가 저장됨
	}
	return result;
}

main()
{
	int data = 0x12345678;
	// data 변수에서 2바이트 크기만 출력함
	printf("%X\n", Getdata(&data, 2)); //%d 넣으면 이상한 값 나온다(overflow?)
}
/*
이 예제는 4바이트 크기의 정수를 저장하는 data 변수가 있는데, 이 변수에 저장된 값을 그대로 출력하지 않는다.
사용자가 type 변수에 값을 1 지정하면 1바이트만 나온다.

포인터 변수에 직접 형 변환을 사용하는 형식은 void *에만 사용할 수 있는 것이 아니라, 모든 포인터에서 사용할 수 있다.
그래서 void * 대신 char*로 선언해 놓고, void *를 사용하는 것처럼 형변환하여 구성된 코드도 있다.





*/