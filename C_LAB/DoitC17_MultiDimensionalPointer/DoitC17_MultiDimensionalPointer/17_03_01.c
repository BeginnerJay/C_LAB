// 매개 변수에 포인터 변수를 잘못 사용한 경우 : 컴파일 오류 없이 실행 시에 오류가 생긴다. 꼭 숙지할 것!
// 8바이트의 동적 메모리를 할당하는 함수 만들기
#include <stdio.h>
#include <malloc.h>
void GetMyData(int *q)
{
	q = (int *)malloc(8); // 8바이트의 메모리를 동적 할당하여 포인터 q에 저장
}

main()
{
	int *p; // p는초기화되지 않아서 쓰레기값(유효하지 않은 값)을 저장하고 있음
	GetMyData(p); // 함수를 호출하여 p에 8바이트 메모리를 할당함
	*p = 5; // 오류 발생 : 할당한 메모리의 첫 4바이트에 값 5를 넣음
	free(p); // 동적으로 할당된 메모리를 해제함
}
// 문제가 발생하는 이유
	// main 함수의 포인터 변수 p에서 GetMyData 함수의 포인터 변수 q로 원하지 않는 주소 값이 전달되었기 때문!
		// GetMyData(p)에서 p의 쓰레기 값이 q에도 저장됨.
		// 할당된 메모리의 주소값은 q에 저장함.
			// q에는 새로 할당한 메모리의 주소가 저장되었을 뿐, p 포인터 변수에는 영향이 없음.
			// 그렇다고 GetMyData에 *p = q 할 수 없음(p는 지역 변수)
		// p는 처음 가지고 있던 쓰레기 값을 그대로 가지고 있는 상황
			// 그 주소에 5를 저장하려고 하면 원하지 않는 주소에 값을 대입하는 것 -> 오류 발생
// 해결 방법
	// main 함수의 지역 변수 p의 값을 변경하고 싶다면, GetMyData 함수에서 변수 p의 주소 값을 전달받아 처리해야 한다.
		// 다른 함수에 선언한 지역 변수의 이름은 사용할 수 없지만, 주소는 사용할 수 있기 때문이다.
		// 그런데 p가 일반 변수가 아니라 1차원 포인터 변수 -> p의 주소값을 전달받는 변수 q를 2차원 포인터로 선언해야!